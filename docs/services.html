<!DOCTYPE html>
<html>
  <head>
    <title>Meiosis Documentation</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="normalize.css">
    <link rel="stylesheet" href="skeleton.css">
    <link rel="stylesheet" href="prism.css">
    <link rel="stylesheet" href="style.css">
  </head>
  <body class="container">
    <script src="prism.js" type="text/javascript"></script>
    <script src="flems.html" type="text/javascript" charset="utf-8"></script>
    <h1><a href="https://meiosis.js.org">Meiosis</a> Documentation</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>Services</h2><p><a href="https://james-forbes.com">James Forbes</a> shared his idea of <em>Services</em>. In this section, we&#39;ll look
at James&#39; version using streams, and another version using
<a href="https://github.com/foxdonut/meiosis/tree/master/helpers/setup">meiosis-setup</a>
with <a href="https://github.com/fuzetsu">Daniel Loomer</a>&#39;s
<a href="https://github.com/fuzetsu/mergerino">Mergerino</a>.</p>
<p>James explains that while one-off actions occur after click events, user input, and so on,
services are for ongoing state synchronization. They can produce computed properties, store and
retrieve state from local storage, and trigger other actions.</p>
<p><a name="using_streams"></a></p>
<h3><a href="#using_streams">Using Streams</a></h3><p>James&#39; version uses streams to implement services. The structure is as follows:</p>
<pre><code class="language-javascript">{
  initial: state =&gt; initialState,
  start: states =&gt; patches
}</code></pre>
<p>A service has an <code>initial</code> function which produces the service&#39;s initial state. The <code>start</code>
function takes the Meiosis <strong>stream</strong> of states and returns a <strong>stream</strong> of patches. The
service emits patches onto this stream.</p>
<p>The application&#39;s initial state is combined with each service&#39;s initial state to produce the
final initial state:</p>
<pre><code class="language-javascript">const services = [ /* ... */ ];

const initialState = () =&gt; {
  const state = {
    boxes: [],
    colors: [&quot;red&quot;, &quot;purple&quot;, &quot;blue&quot;]
  };
  return Object.assign(
    {},
    state,
    services.map(s =&gt; s.initial(state)).reduce(R.merge, {})
  );
};</code></pre>
<p>Then, every service is started by passing in the stream of states, and mapping the resulting stream
of patches onto the <code>update</code> stream:</p>
<pre><code class="language-javascript">services.map(s =&gt; s.start(states).map(update));</code></pre>
<p>When a service emits a patch onto its stream, it is passed on to the <code>update</code> stream.</p>
<h4>Colored Boxes Example</h4><p>James shared an example where you have colored boxes that you can click on to add them to a list.
The boxes are displayed one next to the other, with a description of how many boxes of each color
are in the list. You can remove a box from the list by clicking on it.</p>
<blockquote>
<p>Note that the example code is somewhat different that the &quot;Meiosis style&quot;. There are some nifty
functional programming at play here, and you can learn some nice techniques from this code. But if
you are having some trouble understanding, please know that the code in the next section uses a
style that is closer to what we have been using so far.</p>
</blockquote>
<p>In the example, there are three services:</p>
<ul>
<li><code>StatsService</code>: produces an object that indicates how many boxes of each color.</li>
<li><code>LocalStorageService</code>: stores and retrieves the box data to and from local storage. You will
notice that the box list remains even after reloading the page.</li>
<li><code>DescriptionService</code>: produces the text description of how many boxes of each color are in
the list.</li>
</ul>
<p>Each service has an <code>initial</code> and <code>start</code> function. For example, the <code>StatsService</code> initializes its
state with <code>0</code> for every box color, and computes the number of instances of each color:</p>
<pre><code class="language-javascript">const StatsService = {
  initial(state) {
    return state.colors
      .map(R.objOf)
      .map(K(0))
      .reduce(R.merge, {});
  },
  start(state) {
    return dropRepeats(state.map(x =&gt; x.boxes))
      .map(R.countBy(I))
      .map(R.assoc(&quot;stats&quot;));
  }
};</code></pre>
<p>Notice the call to <code>dropRepeats</code>. This is necessary because the stream of patches produced by the
service is fed back into the Meiosis <code>update</code> stream. This in turn produces an updated state, which
triggers the service again. To avoid an infinite loop, <code>dropRepeats</code> does not emit a value when it
is the same as the previous one:</p>
<pre><code class="language-javascript">function dropRepeats(s) {
  var ready = false;
  var d = m.stream();
  s.map(function (v) {
    if (!ready || v !== d()) {
      ready = true;
      d(v);
    }
  });
  return d;
}</code></pre>
<p>The example uses function patches. Here is the setup for the Meiosis pattern:</p>
<pre><code class="language-javascript">const update = m.stream();
const T = (x, f) =&gt; f(x);
const state = m.stream.scan(T, initialState(), update);
const element = document.getElementById(&quot;app&quot;);
states.map(view(update)).map(v =&gt; m.render(element, v));</code></pre>
<p>The complete example is below.</p>
  <div id="flems1" class="flemscode" style="height:700px"></div>

  <script>
    window.Flems(flems1, {
      files: [{name: "index-streams.js", content: "/* global b, m, R */\n\nconst I = x => x;\nconst o = (f, g) => x => f(g(x));\nconst K = x => () => x;\n\nfunction dropRepeats(s) {\n  var ready = false;\n  var d = m.stream();\n  s.map(function(v) {\n    if (!ready || v !== d()) {\n      ready = true;\n      d(v);\n    }\n  });\n  return d;\n}\n\nconst humanList = s => xs =>\n  xs.length > 1\n    ? xs.slice(0, -1).join(\", \") +\n      \" \" +\n      s +\n      \" \" +\n      xs.slice(-1)\n    : xs.join(\"\");\n\nconst pipe = xs => xs.reduceRight(o, I);\nconst $ = {\n  prop: k => f => o => Object.assign(o, { [k]: f(o[k]) }),\n  get: lens => o => {\n    var y;\n    lens(x => (y = x))(o);\n    return y;\n  }\n};\n\nconst $boxes = $.prop(\"boxes\");\nconst $description = $.prop(\"description\");\nconst $colors = $.prop(\"colors\");\n\nconst Action = {\n  addBox: x =>\n    pipe([K(x), x => xs => xs.concat(x), $boxes]),\n  removeBox: i => $boxes(xs => xs.filter((x, j) => i != j))\n};\n\nconst view = update => state =>\n  m(\n    \".app\" + b.d(\"grid\").ff(\"Helvetica\"),\n    m(\n      \"nav.header\" +\n        b\n          .d(\"flex\")\n          .jc(\"space-between\")\n          .ai(\"center\")\n          .bc(\"steelblue\")\n          .c(\"white\")\n          .p(\"1em\"),\n\n      m(\"h1\" + b.m(0), \"Boxes\"),\n      $.get($colors)(state).map(x =>\n        m(\n          \"button\" +\n            b\n              .bc(x)\n              .c(\"white\")\n              .w(\"2em\")\n              .h(\"2em\")\n              .fs(\"2em\")\n              .m(0)\n              .border(\"none\"),\n          { onclick: pipe([Action.addBox(x), update]) },\n          \"+\"\n        )\n      )\n    ),\n    m(\"p\", $.get($description)(state)),\n    m(\n      \"\" +\n        b\n          .d(\"grid\")\n          .gridTemplateColumns(\"repeat(3, 1fr)\")\n          .alignItems(\"center\")\n          .justifyItems(\"center\")\n          .padding(\"1em\")\n          .gridRowGap(\"1em\")\n          .maxHeight(\"14em\")\n          .overflowY(\"auto\"),\n\n      $.get($boxes)(state).map((x, i) =>\n        m(\n          \"\" +\n            b\n              .bc(x)\n              .c(\"white\")\n              .w(\"4em\")\n              .h(\"4em\"),\n          {\n            onclick: pipe([K(Action.removeBox(i)), update])\n          }\n        )\n      )\n    )\n  );\n\nconst StatsService = {\n  initial(state) {\n    return state.colors\n      .map(R.objOf)\n      .map(K(0))\n      .reduce(R.merge, {});\n  },\n  start(state) {\n    return dropRepeats(state.map(x => x.boxes))\n      .map(R.countBy(I))\n      .map(R.assoc(\"stats\"));\n  }\n};\n\nconst LocalStorageService = {\n  initial() {\n    return [localStorage.getItem(\"v1\")]\n      .filter(Boolean)\n      .map(JSON.parse)\n      .concat({ boxes: [] })\n      .shift();\n  },\n  start(state) {\n    const update = m.stream();\n\n    dropRepeats(state.map(R.pick([\"boxes\"]))).map(x =>\n      localStorage.setItem(\"v1\", JSON.stringify(x))\n    );\n\n    return update;\n  }\n};\n\nconst DescriptionService = {\n  initial() {\n    return {\n      description: \"\"\n    };\n  },\n  start(state) {\n    return dropRepeats(state.map(x => x.stats)).map(\n      R.pipe(\n        R.toPairs,\n        R.groupBy(R.last),\n        R.map(R.map(R.head)),\n        R.map(humanList(\"and\")),\n        R.toPairs,\n        R.map(R.join(\" \")),\n        humanList(\"and\"),\n        x => x + \".\",\n        R.objOf(\"description\"),\n        R.mergeDeepLeft\n      )\n    );\n  }\n};\n\nconst services = [\n  LocalStorageService,\n  StatsService,\n  DescriptionService\n];\n\nconst initialState = () => {\n  const state = {\n    boxes: [],\n    colors: [\"red\", \"purple\", \"blue\"]\n  };\n  return Object.assign(\n    {},\n    state,\n    services.map(s => s.initial(state)).reduce(R.merge, {})\n  );\n};\n\nconst update = m.stream();\nconst T = (x, f) => f(x);\nconst states = m.stream.scan(T, initialState(), update);\nconst element = document.getElementById(\"app\");\nstates.map(view(update)).map(v => m.render(element, v));\n\nservices.map(s => s.start(states).map(update));\n", compiler: "babel"},{name: "app.html", content: "<div id=\"app\"></div>\n<div id=\"tracer\"></div>\n"}],
      links: [{name: "mithril", type: "js", url: "https://unpkg.com/mithril@2.0.4"},{name: "mithril-stream", type: "js", url: "https://unpkg.com/mithril@2.0.4/stream/stream.js"},{name: "ramda", type: "js", url: "https://unpkg.com/ramda@0.25.0/dist/ramda.min.js"},{name: "bss", type: "js", url: "https://unpkg.com/bss@1.3.0/bss.js"}],
      middle: 60,

      autoFocus: false
    })
  </script>


<h4>Flexibility</h4><p>Using streams gives you the flexibility of being able to hook into them and wiring them as you
wish.</p>
<p><a name="using_meiosis_setup"></a></p>
<h3><a href="#using_meiosis_setup">Using Meiosis-Setup</a></h3><p>In Meiosis, instead of having services return streams that emit patches, services patches directly.
These execute <em>before</em> the final state is produced. Then, after the view has re-rendered, <em>effects</em>
can trigger more updates.</p>
<p>A service function receives the current state, the previous state, and the patch.</p>
<p>Service functions run <strong>synchronously</strong> and <strong>in order</strong>. Thus, a service can depend on the changes
made by a previous service.</p>
<p>Effect functions receive <code>({ state, patch, update, actions })</code> and can make synchronous and/or
asynchronous calls to <code>update</code> and/or <code>actions</code>.</p>
<p>Our component structure is thus:</p>
<pre><code class="language-javascript">{
  initial: initialState,
  Actions: update =&gt; actions,
  services: [({ state, previousState, state }) =&gt; patch?,
  effects: [({ state, prevousState, patch, update, actions }) =&gt; void]
}</code></pre>
<h4>With Mergerino</h4><p>In this section, we&#39;ll use <a href="https://github.com/fuzetsu/mergerino">Mergerino</a>, which we looked at in
the <a href="http://meiosis.js.org/tutorial/05-meiosis-with-mergerino.html">tutorial</a>.</p>
<p>To use Mergerino, we emit patches as objects and we use <code>merge</code> as our accumulator:</p>
<pre><code class="language-javascript">const states = m.stream.scan(merge, initial, update);</code></pre>
<p>Remember that previously, we had a stats service and a description service:</p>
<ul>
<li><code>StatsService</code>: produces an object that indicates how many boxes of each color.</li>
<li><code>DescriptionService</code>: produces the text description of how many boxes of each color are in
the list.</li>
</ul>
<p>These services are now:</p>
<pre><code class="language-javascript">const stats = {
  service: ({ state }) =&gt;
    R.applyTo(
      state,
      R.pipe(
        x =&gt; x.boxes,
        R.countBy(I),
        R.always,
        R.objOf(&quot;stats&quot;)
      )
    )
};

const description = {
  service: ({ state }) =&gt;
    R.applyTo(
      state,
      R.pipe(
        x =&gt; x.stats,
        R.toPairs,
        R.groupBy(R.last),
        R.map(R.map(R.head)),
        R.map(humanList(&quot;and&quot;)),
        R.toPairs,
        R.map(R.join(&quot; &quot;)),
        humanList(&quot;and&quot;),
        x =&gt; x + &quot;.&quot;,
        R.objOf(&quot;description&quot;)
      )
    )
};</code></pre>
<p>Each service function takes the state and returns a patch object.</p>
<p>A service function does not need to return anything, however. The <code>storage.service</code> function is one such function, as it only stores the state into local storage:</p>
<pre><code class="language-javascript">const storage = {
  service: ({ state }) =&gt; {
    localStorage.setItem(
      &quot;v1&quot;,
      JSON.stringify({ boxes: state.boxes })
    );
  }
};</code></pre>
<p>You will find the complete example below.</p>
  <div id="flems2" class="flemscode" style="height:700px"></div>

  <script>
    window.Flems(flems2, {
      files: [{name: "index-mergerino.js", content: "/* global b, m, R, Meiosis, mergerino */\nconst merge = mergerino;\n\nconst I = x => x;\n\nconst humanList = s => xs =>\n  xs.length > 1\n    ? xs.slice(0, -1).join(\", \") +\n      \" \" +\n      s +\n      \" \" +\n      xs.slice(-1)\n    : xs.join(\"\");\n\nconst stats = {\n  service: ({ state }) =>\n    R.applyTo(\n      state,\n      R.pipe(\n        x => x.boxes,\n        R.countBy(I),\n        R.always,\n        R.objOf(\"stats\")\n      )\n    )\n};\n\nconst description = {\n  service: ({ state }) =>\n    R.applyTo(\n      state,\n      R.pipe(\n        x => x.stats,\n        R.toPairs,\n        R.groupBy(R.last),\n        R.map(R.map(R.head)),\n        R.map(humanList(\"and\")),\n        R.toPairs,\n        R.map(R.join(\" \")),\n        humanList(\"and\"),\n        x => x + \".\",\n        R.objOf(\"description\")\n      )\n    )\n};\n\nconst storage = {\n  initial: R.applyTo(\n    localStorage.getItem(\"v1\"),\n    R.ifElse(R.isNil, R.always({}), x => JSON.parse(x))\n  ),\n\n  service: ({ state }) => {\n    localStorage.setItem(\n      \"v1\",\n      JSON.stringify({ boxes: state.boxes })\n    );\n  }\n};\n\nconst app = {\n  initial: merge(\n    {\n      boxes: [],\n      colors: [\"red\", \"purple\", \"blue\"]\n    },\n    storage.initial\n  ),\n\n  Actions: update => ({\n    addBox: x => update({ boxes: xs => xs.concat(x) }),\n    removeBox: i =>\n      update({\n        boxes: xs => xs.filter((x, j) => i != j)\n      })\n  }),\n\n  services: [\n    stats.service,\n    description.service,\n    storage.service\n  ]\n};\n\nconst App = {\n  view: ({ attrs: { state, actions } }) =>\n    m(\n      \".app\" + b.d(\"grid\").ff(\"Helvetica\"),\n      m(\n        \"nav.header\" +\n          b\n            .d(\"flex\")\n            .jc(\"space-between\")\n            .ai(\"center\")\n            .bc(\"steelblue\")\n            .c(\"white\")\n            .p(\"1em\"),\n\n        m(\"h1\" + b.m(0), \"Boxes\"),\n        state.colors.map(x =>\n          m(\n            \"button\" +\n              b\n                .bc(x)\n                .c(\"white\")\n                .w(\"2em\")\n                .h(\"2em\")\n                .fs(\"2em\")\n                .m(0)\n                .border(\"none\"),\n            { onclick: () => actions.addBox(x) },\n            \"+\"\n          )\n        )\n      ),\n      m(\"p\", state.description),\n      m(\n        \"\" +\n          b\n            .d(\"grid\")\n            .gridTemplateColumns(\"repeat(3, 1fr)\")\n            .alignItems(\"center\")\n            .justifyItems(\"center\")\n            .padding(\"1em\")\n            .gridRowGap(\"1em\")\n            .maxHeight(\"14em\")\n            .overflowY(\"auto\"),\n\n        state.boxes.map((x, i) =>\n          m(\n            \"\" +\n              b\n                .bc(x)\n                .c(\"white\")\n                .w(\"4em\")\n                .h(\"4em\"),\n            { onclick: () => actions.removeBox(i) }\n          )\n        )\n      )\n    )\n};\n\nconst { states, actions } = Meiosis.mergerino.setup({\n  stream: m.stream,\n  merge,\n  app\n});\n\nm.mount(document.getElementById(\"app\"), {\n  view: () => m(App, { state: states(), actions })\n});\n", compiler: "babel"},{name: "app.html", content: "<div id=\"app\"></div>\n<div id=\"tracer\"></div>\n"}],
      links: [{name: "mithril", type: "js", url: "https://unpkg.com/mithril@2.0.4"},{name: "mithril-stream", type: "js", url: "https://unpkg.com/mithril@2.0.4/stream/stream.js"},{name: "ramda", type: "js", url: "https://unpkg.com/ramda@0.25.0/dist/ramda.min.js"},{name: "bss", type: "js", url: "https://unpkg.com/bss@1.3.0/bss.js"},{name: "meiosis-setup", type: "js", url: "https://unpkg.com/meiosis-setup@4.0.2/dist/meiosis-setup.js"},{name: "mergerino", type: "js", url: "https://unpkg.com/mergerino@0.4.0"}],
      middle: 60,

      autoFocus: false
    })
  </script>


<p><a name="conclusion"></a></p>
<h3><a href="#conclusion">Conclusion</a></h3><p>We can wire up services in different ways, and use them for computed properties, state
synchronization, and other purposes. Please note, however, that not everything belongs in a service,
so it&#39;s important to avoid getting carried away.</p>
<hr>
<p><strong>For more examples of using services and effects, please see the
<a href="http://meiosis.js.org/docs/routing.html">Meiosis Routing</a> documentation.</strong></p>
<hr>
<p><a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="https://meiosis.js.org">Meiosis</a> is developed by
<a href="http://twitter.com/foxdonut00">@foxdonut00</a> /
<a href="https://github.com/foxdonut">foxdonut</a>
and is released under the MIT license.</p>
  </body>
</html>
